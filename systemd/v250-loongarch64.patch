diff --git a/src/basic/architecture.h b/src/basic/architecture.h
index 0b91c69c0b..6966fc5c51 100644
--- a/src/basic/architecture.h
+++ b/src/basic/architecture.h
@@ -20,6 +20,7 @@ typedef enum {
         ARCHITECTURE_ARM_BE,
         ARCHITECTURE_CRIS,
         ARCHITECTURE_IA64,
+        ARCHITECTURE_LOONGARCH32,
         ARCHITECTURE_LOONGARCH64,
         ARCHITECTURE_M68K,
         ARCHITECTURE_MIPS,
@@ -198,10 +199,30 @@ int uname_architecture(void);
 #  elif defined(__SH4A__)
 #    define LIB_ARCH_TUPLE "sh4a-linux-gnu"
 #  endif
-#elif defined(__loongarch64)
-#    pragma message "Please update the Arch tuple of loongarch64 after psABI is stable"
+#elif defined(__loongarch__)
+#  if defined(__loongarch64)
 #    define native_architecture() ARCHITECTURE_LOONGARCH64
-#    define LIB_ARCH_TUPLE "loongarch64-linux-gnu"
+#    if defined(__loongarch_double_float)
+#      define LIB_ARCH_TUPLE "loongarch64-linux-gnuf64"
+#    elif defined(__loongarch_single_float)
+#      define LIB_ARCH_TUPLE "loongarch64-linux-gnuf32"
+#    elif defined(__loongarch_soft_float)
+#      define LIB_ARCH_TUPLE "loongarch64-linux-gnusf"
+#    else
+#      error "Unrecognized loongarch architecture variant"
+#    endif
+#  else
+#    define native_architecture() ARCHITECTURE_LOONGARCH32
+#    if defined(__loongarch_double_float)
+#      define LIB_ARCH_TUPLE "loongarch32-linux-gnuf64"
+#    elif defined(__loongarch_single_float)
+#      define LIB_ARCH_TUPLE "loongarch32-linux-gnuf32"
+#    elif defined(__loongarch_soft_float)
+#      define LIB_ARCH_TUPLE "loongarch32-linux-gnusf"
+#    else
+#      error "Unrecognized loongarch architecture variant"
+#    endif
+#  endif
 #elif defined(__m68k__)
 #  define native_architecture() ARCHITECTURE_M68K
 #  define LIB_ARCH_TUPLE "m68k-linux-gnu"
diff --git a/src/boot/efi/meson.build b/src/boot/efi/meson.build
index 97f0e7607a..8d1b7a5041 100644
--- a/src/boot/efi/meson.build
+++ b/src/boot/efi/meson.build
@@ -16,6 +16,7 @@ efi_arch = {
         'x86_64':  ['x64', 'x86_64'],
         'arm':     ['arm', 'arm'],
         'aarch64': ['aa64', 'aarch64'],
+        'loongarch64': ['loongarch64', 'loongarch64'],
         'riscv64': ['riscv64', 'riscv64'],
 }.get(host_machine.cpu_family(), [])
 
@@ -281,9 +282,9 @@ efi_ldflags = [
         '-z', 'nocombreloc',
         efi_crt0,
 ]
-if efi_arch[1] in ['aarch64', 'arm', 'riscv64']
+if efi_arch[1] in ['aarch64', 'arm', 'loongarch64', 'riscv64']
         efi_ldflags += ['-shared']
-        # Aarch64, ARM32 and 64bit RISC-V don't have an EFI capable objcopy.
+        # Aarch64, ARM32, 64bit LoongArch and RISC-V don't have an EFI capable objcopy.
         # Use 'binary' instead, and add required symbols manually.
         efi_ldflags += ['-Wl,--defsym=EFI_SUBSYSTEM=0xa']
         efi_format = ['-O', 'binary']
diff --git a/src/boot/efi/pe.c b/src/boot/efi/pe.c
index ed3b0b8e94..5896b2d7d3 100644
--- a/src/boot/efi/pe.c
+++ b/src/boot/efi/pe.c
@@ -19,6 +19,8 @@
         #define TARGET_MACHINE_TYPE EFI_IMAGE_MACHINE_AARCH64
 #elif defined(__arm__)
         #define TARGET_MACHINE_TYPE EFI_IMAGE_MACHINE_ARMTHUMB_MIXED
+#elif defined(__loongarch64)
+        #define TARGET_MACHINE_TYPE EFI_IMAGE_MACHINE_LOONGARCH64
 #elif defined(__riscv) && __riscv_xlen == 64
         #define TARGET_MACHINE_TYPE EFI_IMAGE_MACHINE_RISCV64
 #else
diff --git a/src/boot/efi/util.c b/src/boot/efi/util.c
index 6db4ab3969..23cb194936 100644
--- a/src/boot/efi/util.c
+++ b/src/boot/efi/util.c
@@ -23,6 +23,12 @@ UINT64 ticks_read(void) {
         __asm__ volatile ("mrs %0, cntpct_el0" : "=r" (val));
         return val;
 }
+#elif defined(__loongarch64)
+UINT64 ticks_read(void) {
+        UINT64 val;
+        __asm__ volatile ("rdtime.d %0, $zero" : "=r" (val));
+        return val;
+}
 #else
 UINT64 ticks_read(void) {
         UINT64 val = 1;
diff --git a/src/nspawn/nspawn-oci.c b/src/nspawn/nspawn-oci.c
index 9e59d6a814..7e605b1168 100644
--- a/src/nspawn/nspawn-oci.c
+++ b/src/nspawn/nspawn-oci.c
@@ -1694,6 +1694,9 @@ static int oci_seccomp_arch_from_string(const char *name, uint32_t *ret) {
         } table[] = {
                 { "SCMP_ARCH_AARCH64",     SCMP_ARCH_AARCH64     },
                 { "SCMP_ARCH_ARM",         SCMP_ARCH_ARM         },
+#ifdef SCMP_ARCH_LOONGARCH64
+                { "SCMP_ARCH_LOONGARCH64", SCMP_ARCH_LOONGARCH64 },
+#endif
                 { "SCMP_ARCH_MIPS",        SCMP_ARCH_MIPS        },
                 { "SCMP_ARCH_MIPS64",      SCMP_ARCH_MIPS64      },
                 { "SCMP_ARCH_MIPS64N32",   SCMP_ARCH_MIPS64N32   },
diff --git a/src/shared/base-filesystem.c b/src/shared/base-filesystem.c
index 5f5328c8cf..481eec2ff1 100644
--- a/src/shared/base-filesystem.c
+++ b/src/shared/base-filesystem.c
@@ -63,6 +63,20 @@ static const BaseFilesystem table[] = {
                          "usr/lib64\0",                "ld-linux-x86-64.so.2" },
 #  define KNOW_LIB64_DIRS 1
 #elif defined(__ia64__)
+#elif defined(__loongarch64)
+#  define KNOW_LIB64_DIRS 1
+#  if defined(__loongarch_double_float)
+        { "lib64",    0, "usr/lib/"LIB_ARCH_TUPLE"\0"
+                         "usr/lib64\0",                "ld-linux-loongarch-lp64d.so.1" },
+#  elif defined(__loongarch_single_float)
+        { "lib64",    0, "usr/lib/"LIB_ARCH_TUPLE"\0"
+                         "usr/lib64\0",                "ld-linux-loongarch-lp64f.so.1" },
+#  elif defined(__loongarch_soft_float)
+        { "lib64",    0, "usr/lib/"LIB_ARCH_TUPLE"\0"
+                         "usr/lib64\0",                "ld-linux-loongarch-lp64s.so.1" },
+#  else
+#    error "Unknown LoongArch ABI"
+#  endif
 #elif defined(__m68k__)
         /* No link needed. */
 #  define KNOW_LIB64_DIRS 1
diff --git a/src/shared/seccomp-util.c b/src/shared/seccomp-util.c
index 7d2c52e188..1c633a15f6 100644
--- a/src/shared/seccomp-util.c
+++ b/src/shared/seccomp-util.c
@@ -43,6 +43,8 @@ uint32_t seccomp_local_archs[] = {
                 SCMP_ARCH_AARCH64,     /* native */
 #elif defined(__arm__)
                 SCMP_ARCH_ARM,
+#elif defined(__loongarch64)
+                SCMP_ARCH_LOONGARCH64,
 #elif defined(__mips__) && __BYTE_ORDER == __BIG_ENDIAN && _MIPS_SIM == _MIPS_SIM_ABI32
                 SCMP_ARCH_MIPSEL,
                 SCMP_ARCH_MIPS,        /* native */
@@ -117,6 +119,10 @@ const char* seccomp_arch_to_string(uint32_t c) {
                 return "arm";
         case SCMP_ARCH_AARCH64:
                 return "arm64";
+#ifdef SCMP_ARCH_LOONGARCH64
+        case SCMP_ARCH_LOONGARCH64:
+                return "loongarch64";
+#endif
         case SCMP_ARCH_MIPS:
                 return "mips";
         case SCMP_ARCH_MIPS64:
@@ -166,6 +172,10 @@ int seccomp_arch_from_string(const char *n, uint32_t *ret) {
                 *ret = SCMP_ARCH_ARM;
         else if (streq(n, "arm64"))
                 *ret = SCMP_ARCH_AARCH64;
+#ifdef SCMP_ARCH_LOONGARCH64
+        else if (streq(n, "loongarch64"))
+                *ret = SCMP_ARCH_LOONGARCH64;
+#endif
         else if (streq(n, "mips"))
                 *ret = SCMP_ARCH_MIPS;
         else if (streq(n, "mips64"))
@@ -1325,6 +1335,9 @@ int seccomp_protect_sysctl(void) {
 
                 if (IN_SET(arch,
                            SCMP_ARCH_AARCH64,
+#ifdef SCMP_ARCH_LOONGARCH64
+                           SCMP_ARCH_LOONGARCH64,
+#endif
 #ifdef SCMP_ARCH_RISCV64
                            SCMP_ARCH_RISCV64,
 #endif
@@ -1405,6 +1418,9 @@ int seccomp_restrict_address_families(Set *address_families, bool allow_list) {
                 case SCMP_ARCH_X32:
                 case SCMP_ARCH_ARM:
                 case SCMP_ARCH_AARCH64:
+#ifdef SCMP_ARCH_LOONGARCH64
+                case SCMP_ARCH_LOONGARCH64:
+#endif
                 case SCMP_ARCH_MIPSEL64N32:
                 case SCMP_ARCH_MIPS64N32:
                 case SCMP_ARCH_MIPSEL64:
@@ -1651,7 +1667,7 @@ static int add_seccomp_syscall_filter(scmp_filter_ctx seccomp,
 }
 
 /* For known architectures, check that syscalls are indeed defined or not. */
-#if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || (defined(__riscv) && __riscv_xlen == 64)
+#if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || defined(__loongarch64) || (defined(__riscv) && __riscv_xlen == 64)
 assert_cc(SCMP_SYS(shmget) > 0);
 assert_cc(SCMP_SYS(shmat) > 0);
 assert_cc(SCMP_SYS(shmdt) > 0);
@@ -1696,16 +1712,19 @@ int seccomp_memory_deny_write_execute(void) {
                 case SCMP_ARCH_X86_64:
                 case SCMP_ARCH_X32:
                 case SCMP_ARCH_AARCH64:
+#ifdef SCMP_ARCH_LOONGARCH64
+                case SCMP_ARCH_LOONGARCH64:
+#endif
 #ifdef SCMP_ARCH_RISCV64
                 case SCMP_ARCH_RISCV64:
 #endif
-                        filter_syscall = SCMP_SYS(mmap); /* amd64, x32, arm64 and riscv64 have only mmap */
+                        filter_syscall = SCMP_SYS(mmap); /* amd64, x32, arm64, loongarch64 and riscv64 have only mmap */
                         shmat_syscall = SCMP_SYS(shmat);
                         break;
 
                 /* Please add more definitions here, if you port systemd to other architectures! */
 
-#if !defined(__i386__) && !defined(__x86_64__) && !defined(__powerpc__) && !defined(__powerpc64__) && !defined(__arm__) && !defined(__aarch64__) && !defined(__s390__) && !defined(__s390x__) && !(defined(__riscv) && __riscv_xlen == 64)
+#if !defined(__i386__) && !defined(__x86_64__) && !defined(__powerpc__) && !defined(__powerpc64__) && !defined(__arm__) && !defined(__aarch64__) && !defined(__loongarch64) && !defined(__s390__) && !defined(__s390x__) && !(defined(__riscv) && __riscv_xlen == 64)
 #warning "Consider adding the right mmap() syscall definitions here!"
 #endif
                 }
diff --git a/src/test/test-seccomp.c b/src/test/test-seccomp.c
index 7ccfeadbb8..fc0b53989b 100644
--- a/src/test/test-seccomp.c
+++ b/src/test/test-seccomp.c
@@ -126,6 +126,9 @@ TEST(architecture_table) {
                        "x32\0"
                        "arm\0"
                        "arm64\0"
+#ifdef SCMP_ARCH_LOONGARCH64
+                       "loongarch64\0"
+#endif
                        "mips\0"
                        "mips64\0"
                        "mips64-n32\0"
@@ -619,7 +622,7 @@ TEST(memory_deny_write_execute_mmap) {
                 assert_se(seccomp_memory_deny_write_execute() >= 0);
 
                 p = mmap(NULL, page_size(), PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1,0);
-#if defined(__x86_64__) || defined(__i386__) || defined(__powerpc64__) || defined(__arm__) || defined(__aarch64__)
+#if defined(__x86_64__) || defined(__i386__) || defined(__powerpc64__) || defined(__arm__) || defined(__aarch64__) || defined(__loongarch64)
                 assert_se(p == MAP_FAILED);
                 assert_se(errno == EPERM);
 #endif
@@ -691,7 +694,7 @@ TEST(memory_deny_write_execute_shmat) {
 
                 p = shmat(shmid, NULL, SHM_EXEC);
                 log_debug_errno(p == MAP_FAILED ? errno : 0, "shmat(SHM_EXEC): %m");
-#if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__)
+#if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || defined(__loongarch64)
                 assert_se(p == MAP_FAILED);
                 assert_se(errno == EPERM);
 #endif
